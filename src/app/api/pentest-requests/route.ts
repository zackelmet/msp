import { NextRequest, NextResponse } from 'next/server';
import { getFirestore } from 'firebase-admin/firestore';
import { initializeApp, getApps, cert } from 'firebase-admin/app';

// Initialize Firebase Admin
if (!getApps().length && typeof window === 'undefined' && process.env.FIREBASE_SERVICE_ACCOUNT_KEY) {
  try {
    const serviceAccount = JSON.parse(
      Buffer.from(process.env.FIREBASE_SERVICE_ACCOUNT_KEY, 'base64').toString('utf-8')
    );

    initializeApp({
      credential: cert(serviceAccount),
    });
  } catch (error) {
    console.warn('Firebase Admin initialization failed:', error);
  }
}

function getDb() {
  if (getApps().length === 0) {
    throw new Error('Firebase Admin not initialized');
  }
  return getFirestore();
}

export async function POST(request: NextRequest) {
  try {
    const db = getDb();
    const data = await request.json();

    // Validate required fields
    const required = ['userId', 'userEmail', 'tier', 'contactName', 'companyName', 'targetDomains', 'scopeDescription'];
    for (const field of required) {
      if (!data[field]) {
        return NextResponse.json(
          { error: `Missing required field: ${field}` },
          { status: 400 }
        );
      }
    }

    // Create request document
    const requestData = {
      ...data,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date(),
      proposalSent: false,
    };

    const docRef = await db.collection('pentestRequests').add(requestData);

    // Log activity
    await db.collection('activityLogs').add({
      userId: data.userId,
      type: 'manual_pentest_requested',
      details: {
        requestId: docRef.id,
        tier: data.tier,
        companyName: data.companyName,
      },
      timestamp: new Date(),
    });

    return NextResponse.json({
      success: true,
      requestId: docRef.id,
      message: 'Pentest request submitted successfully',
    });
  } catch (error: any) {
    console.error('Error creating pentest request:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to submit request' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const db = getDb();
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');
    const status = searchParams.get('status');
    const isAdmin = searchParams.get('isAdmin') === 'true';

    let query: any = db.collection('pentestRequests');

    // Non-admin users can only see their own requests
    if (!isAdmin && userId) {
      query = query.where('userId', '==', userId);
    }

    // Filter by status
    if (status) {
      query = query.where('status', '==', status);
    }

    const snapshot = await query.orderBy('createdAt', 'desc').get();

    const requests = snapshot.docs.map((doc: any) => ({
      id: doc.id,
      ...doc.data(),
      createdAt: doc.data().createdAt?.toDate?.()?.toISOString() || null,
      updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString() || null,
      preferredStartDate: doc.data().preferredStartDate?.toDate?.()?.toISOString() || null,
      deadline: doc.data().deadline?.toDate?.()?.toISOString() || null,
    }));

    return NextResponse.json({ requests });
  } catch (error: any) {
    console.error('Error fetching requests:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to fetch requests' },
      { status: 500 }
    );
  }
}

export async function PATCH(request: NextRequest) {
  try {
    const db = getDb();
    const { requestId, updates, adminUserId } = await request.json();

    if (!requestId) {
      return NextResponse.json(
        { error: 'Request ID required' },
        { status: 400 }
      );
    }

    const updateData = {
      ...updates,
      updatedAt: new Date(),
    };

    await db.collection('pentestRequests').doc(requestId).update(updateData);

    // Log status change
    if (updates.status) {
      await db.collection('activityLogs').add({
        userId: adminUserId || 'system',
        type: 'pentest_request_updated',
        details: {
          requestId,
          newStatus: updates.status,
          adminNotes: updates.adminNotes,
        },
        timestamp: new Date(),
      });
    }

    return NextResponse.json({ success: true });
  } catch (error: any) {
    console.error('Error updating request:', error);
    return NextResponse.json(
      { error: error.message || 'Failed to update request' },
      { status: 500 }
    );
  }
}
