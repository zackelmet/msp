import { NextRequest, NextResponse } from 'next/server';
import { adminDb } from '@/lib/firebase/firebaseAdmin';
import { FieldValue, Transaction } from 'firebase-admin/firestore';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { type, targetUrl, userRoles, endpoints, additionalContext, userId } = body;

    if (!userId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    if (!type || !targetUrl) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Verify user has credits
    const userRef = adminDb.collection('users').doc(userId);
    const userDoc = await userRef.get();
    
    if (!userDoc.exists) {
      return NextResponse.json(
        { error: 'User not found' },
        { status: 404 }
      );
    }

    const userData = userDoc.data();
    const credits = userData?.credits || {};
    const creditType = type === 'web_app' ? 'web_app' : 'external_ip';
    const availableCredits = credits[creditType] || 0;

    if (availableCredits < 1) {
      return NextResponse.json(
        { error: 'Insufficient credits' },
        { status: 402 }
      );
    }

    // Create pentest document
    const pentestRef = adminDb.collection('pentests').doc();
    const pentestData = {
      id: pentestRef.id,
      userId,
      type,
      targetUrl,
      userRoles: userRoles || null,
      endpoints: endpoints || null,
      additionalContext: additionalContext || null,
      status: 'pending',
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
      results: null,
      vulnerabilities: [],
      completedAt: null,
    };

    // Use transaction to deduct credit and create pentest atomically
    await adminDb.runTransaction(async (transaction: Transaction) => {
      // Deduct credit
      transaction.update(userRef, {
        [`credits.${creditType}`]: FieldValue.increment(-1),
      });

      // Create pentest
      transaction.set(pentestRef, pentestData);
    });

    // Send pentest job to Make.com webhook
    const makeWebhookUrl = 'https://hook.us2.make.com/ct4m2lrjs7e64yu94jaoyaesmto3crsd';
    try {
      const webhookResponse = await fetch(makeWebhookUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          pentestId: pentestRef.id,
          userId,
          type,
          targetUrl,
          userRoles: userRoles || null,
          endpoints: endpoints || null,
          additionalContext: additionalContext || null,
          callbackUrl: `${process.env.NEXT_PUBLIC_SITE_URL}/api/pentests`,
          webhookSecret: process.env.GCP_WEBHOOK_SECRET || '',
        }),
      });

      if (!webhookResponse.ok) {
        console.error('Make.com webhook failed:', await webhookResponse.text());
        // Don't fail the request — pentest doc is created, job can be retried
      } else {
        console.log('Make.com webhook accepted for pentest', pentestRef.id);
      }
    } catch (webhookError) {
      console.error('Error sending to Make.com webhook:', webhookError);
      // Don't fail the request — pentest is created
    }

    return NextResponse.json({
      pentestId: pentestRef.id,
      message: 'Pentest started successfully',
    });
  } catch (error: any) {
    console.error('Error creating pentest:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('userId');

    if (!userId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    // Get user's pentests
    const pentestsSnapshot = await adminDb
      .collection('pentests')
      .where('userId', '==', userId)
      .orderBy('createdAt', 'desc')
      .limit(50)
      .get();

    const pentests = pentestsSnapshot.docs.map((doc: any) => ({
      id: doc.id,
      ...doc.data(),
    }));

    return NextResponse.json({ pentests });
  } catch (error: any) {
    console.error('Error fetching pentests:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}

// PATCH endpoint for backend to submit completed pentest results
export async function PATCH(request: NextRequest) {
  try {
    // Verify webhook secret
    const webhookSecret = request.headers.get('X-Webhook-Secret');
    if (webhookSecret !== process.env.GCP_WEBHOOK_SECRET) {
      return NextResponse.json(
        { error: 'Unauthorized - Invalid webhook secret' },
        { status: 401 }
      );
    }

    const body = await request.json();
    const { pentestId, status, results, vulnerabilities, error } = body;

    if (!pentestId) {
      return NextResponse.json(
        { error: 'Missing pentestId' },
        { status: 400 }
      );
    }

    const pentestRef = adminDb.collection('pentests').doc(pentestId);
    const pentestDoc = await pentestRef.get();

    if (!pentestDoc.exists) {
      return NextResponse.json(
        { error: 'Pentest not found' },
        { status: 404 }
      );
    }

    // Update pentest with results
    const updateData: any = {
      status: status || 'completed',
      updatedAt: FieldValue.serverTimestamp(),
      completedAt: FieldValue.serverTimestamp(),
    };

    if (results) {
      updateData.results = results;
    }

    if (vulnerabilities) {
      updateData.vulnerabilities = vulnerabilities;
    }

    if (error) {
      updateData.error = error;
      updateData.status = 'failed';
    }

    await pentestRef.update(updateData);

    return NextResponse.json({
      success: true,
      message: 'Pentest results updated successfully',
    });
  } catch (error: any) {
    console.error('Error updating pentest results:', error);
    return NextResponse.json(
      { error: error.message || 'Internal server error' },
      { status: 500 }
    );
  }
}
