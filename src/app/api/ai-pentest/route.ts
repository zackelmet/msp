import { NextRequest, NextResponse } from "next/server";
import { initializeAdmin } from "@/lib/firebase/firebaseAdmin";
import { randomUUID } from "crypto";

// AI Pentest endpoint - orchestrates multiple scans
export async function POST(request: NextRequest) {
  try {
    const admin = initializeAdmin();
    const auth = admin.auth();
    const firestore = admin.firestore();

    // Verify auth
    const authHeader = request.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Unauthorized - No token provided" },
        { status: 401 }
      );
    }

    const token = authHeader.split("Bearer ")[1];
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(token);
    } catch (error) {
      return NextResponse.json(
        { error: "Unauthorized - Invalid token" },
        { status: 401 }
      );
    }

    const userId = decodedToken.uid;
    const body = await request.json();

    const {
      targets,
      scanTypes,
      engagementId,
      options,
      name,
    } = body;

    if (!targets || !Array.isArray(targets) || targets.length === 0) {
      return NextResponse.json(
        { error: "Missing required field: targets (array)" },
        { status: 400 }
      );
    }

    if (!scanTypes || !Array.isArray(scanTypes) || scanTypes.length === 0) {
      return NextResponse.json(
        { error: "Missing required field: scanTypes (array)" },
        { status: 400 }
      );
    }

    // Validate scan types
    const validScanTypes = ["nmap", "openvas", "zap"];
    for (const scanType of scanTypes) {
      if (!validScanTypes.includes(scanType)) {
        return NextResponse.json(
          { error: `Invalid scan type: ${scanType}` },
          { status: 400 }
        );
      }
    }

    // Check user has credits for the scans
    const userDoc = await firestore.collection("users").doc(userId).get();
    if (!userDoc.exists) {
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    const userData = userDoc.data();
    const scannerLimits = userData?.scannerLimits || { nmap: 0, openvas: 0, zap: 0 };
    const scannersUsed = userData?.scannersUsedThisMonth || { nmap: 0, openvas: 0, zap: 0 };

    // Calculate total scans needed per type
    const scansNeeded: Record<string, number> = {};
    for (const scanType of scanTypes) {
      scansNeeded[scanType] = targets.length;
    }

    // Check if user has enough credits
    for (const [scanType, needed] of Object.entries(scansNeeded)) {
      const available = (scannerLimits[scanType] || 0) - (scannersUsed[scanType] || 0);
      if (available < needed) {
        return NextResponse.json(
          {
            error: `Insufficient ${scanType} credits. Need ${needed}, have ${available}`,
          },
          { status: 403 }
        );
      }
    }

    // Create AI Pentest run record
    const runId = randomUUID();
    const totalScans = targets.length * scanTypes.length;

    const aiPentestRun = {
      id: runId,
      name: name || `AI Pentest - ${new Date().toISOString()}`,
      userId,
      engagementId: engagementId || null,
      status: "queued",
      targets,
      scanTypes,
      options: options || {},
      startTime: admin.firestore.FieldValue.serverTimestamp(),
      scanIds: [],
      progress: {
        total: totalScans,
        completed: 0,
        failed: 0,
      },
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
    };

    await firestore.collection("aiPentestRuns").doc(runId).set(aiPentestRun);

    // Log activity
    await firestore.collection("activityLogs").add({
      userId,
      type: "ai_scan",
      title: `AI Pentest Started: ${aiPentestRun.name}`,
      description: `Automated scan of ${targets.length} targets with ${scanTypes.join(", ")}`,
      engagementId: engagementId || null,
      metadata: {
        runId,
        targets: targets.length,
        scanTypes,
        totalScans,
      },
      timestamp: admin.firestore.FieldValue.serverTimestamp(),
    });

    // Queue individual scans
    const scanIds: string[] = [];
    const batch = firestore.batch();

    for (const target of targets) {
      for (const scanType of scanTypes) {
        const scanId = randomUUID();
        scanIds.push(scanId);

        const scanDoc = firestore.collection("scans").doc(scanId);
        batch.set(scanDoc, {
          scanId,
          userId,
          type: scanType,
          target,
          status: "queued",
          aiPentestRunId: runId,
          engagementId: engagementId || null,
          options: options?.[scanType] || {},
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
      }
    }

    await batch.commit();

    // Update run with scan IDs
    await firestore.collection("aiPentestRuns").doc(runId).update({
      scanIds,
      status: "running",
    });

    // Update user scan usage
    const usageUpdates: Record<string, any> = {};
    for (const [scanType, needed] of Object.entries(scansNeeded)) {
      usageUpdates[`scannersUsedThisMonth.${scanType}`] =
        admin.firestore.FieldValue.increment(needed);
    }
    await firestore.collection("users").doc(userId).update(usageUpdates);

    // TODO: Trigger actual scan execution via Cloud Run/Pub-Sub
    // For now, the scans are queued and can be picked up by a worker

    return NextResponse.json({
      success: true,
      runId,
      totalScans,
      scanIds,
      message: `Queued ${totalScans} scans across ${targets.length} targets`,
    });
  } catch (error: any) {
    console.error("Error creating AI pentest run:", error);
    return NextResponse.json(
      { error: error.message || "Internal server error" },
      { status: 500 }
    );
  }
}

export async function GET(request: NextRequest) {
  try {
    const admin = initializeAdmin();
    const auth = admin.auth();
    const firestore = admin.firestore();

    // Verify auth
    const authHeader = request.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      return NextResponse.json(
        { error: "Unauthorized - No token provided" },
        { status: 401 }
      );
    }

    const token = authHeader.split("Bearer ")[1];
    let decodedToken;
    try {
      decodedToken = await auth.verifyIdToken(token);
    } catch (error) {
      return NextResponse.json(
        { error: "Unauthorized - Invalid token" },
        { status: 401 }
      );
    }

    const userId = decodedToken.uid;
    const { searchParams } = new URL(request.url);
    const runId = searchParams.get("runId");

    if (runId) {
      // Get specific run
      const runDoc = await firestore.collection("aiPentestRuns").doc(runId).get();
      if (!runDoc.exists) {
        return NextResponse.json({ error: "Run not found" }, { status: 404 });
      }

      const runData = runDoc.data();
      if (runData?.userId !== userId) {
        return NextResponse.json({ error: "Unauthorized" }, { status: 403 });
      }

      return NextResponse.json({ run: { id: runDoc.id, ...runData } });
    }

    // Get all runs
    const query = firestore
      .collection("aiPentestRuns")
      .where("userId", "==", userId)
      .orderBy("createdAt", "desc")
      .limit(50);

    const snapshot = await query.get();
    const runs = snapshot.docs.map((doc) => ({
      id: doc.id,
      ...doc.data(),
    }));

    return NextResponse.json({ runs });
  } catch (error: any) {
    console.error("Error fetching AI pentest runs:", error);
    return NextResponse.json(
      { error: error.message || "Internal server error" },
      { status: 500 }
    );
  }
}
